'use strict';
// =============================================================
// functions
// Вспомогательные функции для маятника
// =============================================================

define(['my_math/equation_4',
        'my_math/math_functions',
        'pendulum_tools/period'],
       function(equation_4, // Решение уравнения 4-й степени
                math_functions, // Математические функции
                period){ // Период колебаний

    var getDTV, // Функция для определения dt и v2
        getX, // Функция для определения следующей координаты по оси X
        getXal, // Функция для определения X по заданному углу
        getY, // Функция для определения координаты по оси Y в зависимости от X
        getV, // Функция для определения скорости в точке с координатой X
        getA, // Функция для определения ускорения в точке с координатой X
        getAlfa, // Функция для определения угла отклонения маятника
        proportion; // Функция для установки пропроции 1х1




    // ===============================================================
    // getDTV
    // ===============================================================
    // Функция для определения dt и v2
    // arg = {x1, x2, v1, g, l}
    //      x1, x2 - Отрезок пути по оси X
    //      v1 - Скорость в точке x1
    //      g - ускорение свободного падения
    //      l - длина маятника
    // return {dt, v2, iZ}
    //      dt - Время прохождения от x1 до x2
    //      v2 - Скорость в точке x2
    //      iZ - Знак. (+1 или -1) 
    //          '+1' - Маятник приближается к точке покоя
    //          '-1' - Маятник удаляется от точки покоя
    getDTV = function(arg){
        var dPt, // dt без начальной скорости
            pV2, // v без начальной скорости
            iZ, // Знак. (+1 или -1)
            result = {};

        // Определение iZ
        if ( (arg.x1 < 0 && arg.x2 <= 0 && arg.x2 > arg.x1) ||
             (arg.x1 > 0 && arg.x2 >= 0 && arg.x2 < arg.x1) ) {

            iZ = 1;
        } else {

            if ( (arg.x1 >= 0 && arg.x2 > 0 && arg.x2 > arg.x1) ||
                 (arg.x1 <= 0 && arg.x2 < 0 && arg.x2 < arg.x1) ) {

                iZ = -1;
            };

        };

        result.iZ = iZ;

        dPt = Math.sqrt( Math.abs(arg.x2 - arg.x1) / (arg.g * Math.abs(arg.x2) * Math.sqrt(1 - Math.pow(arg.x2 / arg.l, 2)) / arg.l) );

        pV2 = (arg.x2 - arg.x1) / dPt;

        result.v2 = arg.v1 + iZ * pV2;

        if (iZ === -1 && Math.floor(Math.abs(result.v2 * Math.pow(10, 10))) === 0 ){
            // Если v2 === 0 на подъёме, тогда dt = бесконечность
            result.v2 = 0;
            result.dt = Infinity;

        } else {

            result.dt = (arg.x2 - arg.x1) / result.v2;

        };


        return result;
    };




    // ===============================================================
    // getX
    // ===============================================================
    // Функция для определения следующей координаты по оси X
    // arg = {l, g, x1, dt},   x0
    //      l - Длина маятника (м)
    //      g - Ускорение свободного падения (м/с^2)
    //      x1 - Предыдущая координата по оси X (м)
    //      dt - Промежуток времени (с)
    // x0 - предшевствующая координата, для определения направления
    getX = function(arg, x0){
        var a, b, c, d, e, // Коэффициенты уравнения 4-й степени
            i, newX, w, // Вспомогательные переменные
            x, // {x, f},  x - Массив корней уравнения (x[0] и x[1]),  f - Функция f(x)
            j, // 1 или 0 (1 - движение влево) (0 - движение вправо)
            result;

            newX = new Array();



        // ===================================================================================

        w = Math.pow(arg.g, 2) * Math.pow(arg.dt, 4) / Math.pow(arg.l, 2);

        a = w / Math.pow(arg.l, 2);
        b = 0;
        c = 1 - w;
        d = -2 * arg.x1;
        e = Math.pow(arg.x1, 2);

        // ===================================================================================



        x = equation_4.equation4Ferrari(a, b, c, d, e);

        // Выбор одного нужного корня:
        if (!x0) {
            arg.x1 > 0 ? j = 1 : j = 0;
        } else {
            x0 > arg.x1 ? j = 1 : j = 0;
        };


        if (j === 1) { // ================== Движение влево

            for(i = 0; i < x.x.length; i++){
                if ( x.x[i] < arg.x1 ) {
                    newX.push(x.x[i]);
                }
            };

            x.x.length > 0 ? result = Math.max.apply( Math, newX ) : result = undefined;

        } else { // ================== Движение вправо

            for(i = 0; i < x.x.length; i++){
                if ( x.x[i] > arg.x1 ) {
                    newX.push(x.x[i]);
                }
            };

            x.x.length > 0 ? result = Math.min.apply( Math, newX ) : result = undefined;

        };

        return result;
    };




    // ===============================================================
    // getXal
    // ===============================================================
    // Функция для определения X по заданному углу и длине маятника
    // alfa - угол наклона маятника
    // l - длина маятника
    getXal = function(alfa, l){

        return l * Math.sin(alfa);
    };




    // ===============================================================
    // getY
    // ===============================================================
    // Функция для определения координаты по оси Y в зависимости от X
    // x - Координата по оси X
    // l - Длина маятника
    getY = function(x, l){

        return l - Math.sqrt(Math.pow(l, 2) - Math.pow(x, 2));
    };




    // ===============================================================
    // getAlfa
    // ===============================================================
    // Функция для определения угла отклонения маятника (в радианах)
    // arg = {x1, l}
    //      x1 - Координата по оси X
    //      l - Длина маятника
    getAlfa = function(arg){

        return Math.asin(arg.x1 / arg.l);
    };




    // ===============================================================
    // getV
    // ===============================================================
    // Функция для определения скорости в точке с координатой x2
    // arg = {v1, x1, x2, dt}
    //      v1 - Скорость в точке x1
    //      x1 - Предыдущая координата по оси X
    //      x2 - Текущая координата по оси X
    //      dt - Время прохождения из точки x1 в точку x2
    getV = function(arg){

        return arg.v1 + Math.abs(arg.x1 - arg.x2) / arg.dt;
    };




    // ===============================================================
    // getA
    // ===============================================================
    // Функция для определения ускорения в точке с координатой X
    // arg = {g, l, x, alfa}
    //      g - Ускорение свободного падения
    //      l - Длина маятника
    //      x - координата по оси X
    //      alfa - угол отклонения
    getA = function(arg){

        return arg.g * Math.sin(arg.alfa) * Math.cos(arg.alfa);
    };




    // ========================================================================
    // proportion
    // ========================================================================
    // Функция для установки пропроции 1х1
    // Она возвращает такие диапазоны по оси X и Y, которые обеспечивают правильные пропорции
    // diapasonX - Необходимый диапазон по оси X {x1, x2}
    // diapasonY - Необходимый диапазон по оси Y {y1, y2}
    // w - Ширина canvas
    // h - Высота canvas
    // return {{x1, x2}, {y1, y2}}
    proportion = function(diapasonX, diapasonY, w, h){
        var x, y,
            x1, x2, y1, y2,
            dx = dy = 0;

        x = diapasonX.x2 - diapasonX.x1;
        y = diapasonY.y2 - diapasonY.y1;


        if ((w >= h && x >  y) ||
            (w <  h && x >= y)) {

            dy = x * h / w - y;
        } else {

            if ((w <  h && x <= y) ||
                (w <= h && x <  y)) {

                dx = y * w / h - x;
            };
        };


        x1 = diapasonX.x1 - dx / 2;
        x2 = diapasonX.x2 + dx / 2;

        y1 = diapasonY.y1 - dy / 2;
        y2 = diapasonY.y2 + dy / 2;


        return {
            x: {x1: x1, x2: x2},
            y: {y1: y1, y2: y2}
        };
    };




    return {
        getDTV: getDTV,
        getX: getX,
        getXal: getXal,
        getY: getY,
        getAlfa: getAlfa,
        getV: getV,
        getA: getA,
        period: period.period,
        proportion: proportion
    };
});